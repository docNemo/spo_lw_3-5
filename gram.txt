int /[0-9]+/ { int(text) }
float /[0-9]+(\.[0-9]*)?([eE][\+\-]?[0-9]+)?/ { float(text) }
plus /\+/
minus /\-/
mul /\*/
del /\//
pow /\^/
func /func/
let /let/
lparen /\(/
rparen /\)/
comma /,/
assign /=/
doublep /:/
type /int|float/ {text}
/ +/
id /[a-z_][a-z_0-9]*/ {text}

%%

%top {
from classes import *
}


E -> %left1 E plus  E { make(BinaryOp, '+', _1, _3) }
   | %left1 E minus E { make(BinaryOp, '-', _1, _3) }
   | %left2 E mul E { make(BinaryOp, '*', _1, _3) }
   | %left2 E del E { make(BinaryOp, '/', _1, _3) }
   | %right3 E pow E { make(BinaryOp,'^', _1, _3) }
   | lparen E rparen { _2 }
   | id { makeId(Id, _1) }
   | int { make(Literal, _1, "int") }
   | float { make(Literal, _1, "float") }
   | %non4 minus E { make(UnaryOp, '-', _2) }	
   | %right0 let id assign E { makeId(Assign, _2, _4) }
   | %non0 func id lparen Args rparen assign FBody { makeF(_2, _4, _7) }
   | id lparen ArgsCall rparen { makeC(Call, _1, _3) }
   ;

FBody -> %left1 FBody plus  FBody { makeFBody(BinaryOp, '+', _1, _3) }
   | %left1 FBody minus FBody { makeFBody(BinaryOp, '-', _1, _3) }
   | %left2 FBody mul FBody { makeFBody(BinaryOp, '*', _1, _3) }
   | %left2 FBody del FBody { makeFBody(BinaryOp, '/', _1, _3) }
   | %right3 FBody pow FBody { makeFBody(BinaryOp,'^', _1, _3) }
   | lparen FBody rparen { _2 }
   | id { makeFBodyParam(Id, _1) }
   | int { makeFBody(Literal, _1, "int") }
   | float { makeFBody(Literal, _1, "float") }
   | %non4 minus FBody { makeFBody(UnaryOp, '-', _2) }
   | id lparen ArgsCallF rparen { makeC(Call, _1, _3) }
   ;

Args ->
      | Args1  { _1 }
   ;

Args1 -> id doublep type comma Args1 { [makeFArgs(Param,_1, _3)] + _5 }
      | id doublep type { [makeFArgs(Param,_1, _3)] }
      ;

ArgsCallF ->
      | Args1Call  { _1 }
   ;

Args1CallF -> FBody comma Args1CallF { [_1] + _3 }
      | FBody { [_1] }
      ;

ArgsCall ->
      | Args1Call  { _1 }
   ;

Args1Call -> E comma Args1Call { [_1] + _3 }
      | E { [_1] }
      ;