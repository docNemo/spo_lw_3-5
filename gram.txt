int /[0-9]+/ { int(text) }
float /[0-9]+(\.[0-9]*)?([eE][\+\-]?[0-9]+)?/ { float(text) }
plus /\+/
minus /\-/
mul /\*/
del /\//
pow /\^/
func /func/
let /let/
lparen /\(/
rparen /\)/
comma /,/
assign /=/
doublep /:/
semicol /;/
type /int|float/ {text}
/[ \n\t]+/
id /[a-z_][a-z_0-9]*/ {text}

%%

%top {
from classes import *
}

SS -> S semicol SS { [_1] + _3 }
   | S { [_1] } ;

S -> E {_1}
   | D {_1}
   | A {_1}
   ;

D -> %non0 func id lparen Args rparen assign E { makeF(_2, _4, _7) }
   ;
   
A -> %right0 let id assign E { makeId(Assign, _2, _4) }
   ;

E -> %left1 E plus  E { make(BinaryOp, '+', _1, _3) }
   | %left1 E minus E { make(BinaryOp, '-', _1, _3) }
   | %left2 E mul E { make(BinaryOp, '*', _1, _3) }
   | %left2 E del E { make(BinaryOp, '/', _1, _3) }
   | %right3 E pow E { make(BinaryOp,'^', _1, _3) }
   | lparen E rparen { _2 }
   | id { Id(_1) }
   | int { make(Int, _1) }
   | float { make(Float, _1) }
   | %non4 minus E { make(UnaryOp, '-', _2) }   
   | id lparen ArgsCall rparen { makeC(Call, _1, _3) }
   ;

Args ->
      | Args1  { _1 }
   ;

Args1 -> id doublep type comma Args1 { [Param(_1, _3)] + _5 }
      | id doublep type { [Param(_1, _3)] }
      ;

ArgsCall ->
      | Args1Call  { _1 }
   ;

Args1Call -> E comma Args1Call { [_1] + _3 }
      | E { [_1] }
      ;